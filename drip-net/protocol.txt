Overview of the protocol we'll follow to transmit files p2p over a local area network:

1. mDNS Discovery:
   Advertise _fileshare._tcp.local with instance name Peer-<device_id>, including IP,
   signaling port, and device ID using mDNS multicast to 224.0.0.251:5353.

   When a service is found, add the peer to the list with its IP, port, and device ID,
   device type (mobile/desktop0.

   When a service is removed, remove the peer from the list.

2. This list of peers will be displayed to the user. For security purposes, the user
   can choose which devices they will authorize. This list of authorized devices
   should be cached to a file for convenience sake. So WebRTC connections are not
   created automatically between unknown peers and we are always the initializing device.

   TODO: enforcing security between authorized devices, to avoid man in the middle
         attacks and stuff

   The streaming model will be *one machine to many*, so after authorization
   (or if the device is already authorized),
   create an SDP offer, set local session description, and send it to the peer’s
   TCP signaling port using JSON.

   If no answer is received within 10 seconds, retry up to 3 times with exponential
   backoff (1s, 2s, 4s). If all retries fail, mark the peer as not connected.
   Show an error in the app UI that the peer couldn't be connected to.

   Otherwise, wait for an offer.

3. Receive Offer:
   Set remote description. Create an answer, set local session description, and
   send the answer via TCP.

   Add the peer who sent us the offer to our list of authorized devices automatically.

   TODO: if machine A connects to machine B and machine C, how can machine B know
         to automatically add machine C as authorized too?

   Add the peer to the list if it's not already added and mark connection state as
   initiating (we're the responder)

4. Receive Answer:
   Set remote session description.

   Send our ICE candidates via TCP (we're the initiator).

5. Receive ICE Candidate:

   If remote and local descriptors are not set, buffer the responder’s or
   initiator's ICE candidate; otherwise, set it.

   Discard buffered candidates after a 30-second timeout if descriptors are not set.

   If responder:
   Send our ICE candidates via TCP.

6. Data Channel Opens:
   Mark the peer’s connection state as connected.
   We can now transfer data!

7. ICE State Change:
   If disconnected or failed, set peer state to not connected, close the WebRTC
   connection, and remove associated resources.

8. Transfering files:
   First send a START_TRANSFER message, listing the file name, it's final size,
   the number of chunks, it's mimetype, and so on.
   The other device HAS to get this, so ensure that we get a START_TRANSFER_ACKNOLEDGED
   message back.

   Break up the file into chunks. Hash each chunk so we can verify that it hasn't
   been corrupted when we receive it. Send over each chunk. Also send over the
   chunk index so we know what order the chunk should be in.

   TODO: pending transfers

   TODO: resuming transfers

   TODO: cancelling transfers
