Overview of the protocol we'll follow to transmit files p2p over a local area network:

TODO: how to enfore security

1. mDNS Discovery:
   Advertise _fileshare._tcp.local with instance name Peer-<device_id>, including IP,
   signaling port, and device ID using mDNS multicast to 224.0.0.251:5353.

   When a service is found, add the peer to the list with its IP, port, and device ID,
   device type (mobile/desktop0.

   When a service is removed, remove the peer from the list.

2. This list of peers will be displayed to the user. For security purposes, the user
   can choose which devices they will authorize. This list of authorized devices
   should be cached to a file for convenience sake. So WebRTC connections are not
   created automatically between unknown peers.

   When initializing a WebRTC connection there are 2 possible cases:
   - We authorized the peer, so we're always the initiator (since the peer wouldn't
     have us authorized already) (we're manually opening a new connection)
   - We already have the peer authorized, so we're automatically creating a connection

   In any case, we'll use the perfect negotiation pattern to handle collisions,
   where 2 peers send offers to each other. The nice thing about it is that
   both peers can share the exact same code.

   We'll determine if the user is "polite" or "impolite". If we're polite, when we
   receive an offer, we rollback our own connection and accept the offer. If we're
   impolite, we just set a flag to ignore all subsequent offers, and continue
   with our own offer.

   The streaming model will be *one machine to many*, so after authorization
   (or if the device is already authorized),
   create an SDP offer, set local session description, and send it to the peer’s
   TCP signaling port using JSON.

   If no answer is received within 10 seconds, retry up to 3 times with exponential
   backoff (1s, 2s, 4s). If all retries fail, mark the peer as not connected.
   Show an error in the app UI that the peer couldn't be connected to.

   Otherwise, wait for an offer.

3. Receive Offer:
   Set remote description. Create an answer, set local session description, and
   send the answer via TCP.

   Add the peer who sent us the offer to our list of authorized devices automatically.

   Add the peer to the list if it's not already added and mark connection state as
   initiating (we're the responder)

4. Receive Answer:
   Set remote session description.

   Send our ICE candidates via TCP (we're the initiator).

5. Receive ICE Candidate:

   If remote and local descriptors are not set, buffer the responder’s or
   initiator's ICE candidate; otherwise, set it.

   Discard buffered candidates after a 30-second timeout if descriptors are not set.

   If responder:
   Send our ICE candidates via TCP.

6. Data Channel Opens:
   Mark the peer’s connection state as connected.
   We can now transfer data!

7. ICE State Change:
   If disconnected or failed, set peer state to not connected, close the WebRTC
   connection, and remove associated resources.

8. Transfering files:
   First send a START_TRANSFER message, listing the file name, it's final size,
   the number of chunks, it's mimetype, file permissions (how to make that cross platform?),
   and so on. The other device HAS to get this, so ensure that we get a
   START_TRANSFER_ACKNOLEDGED message back.

   Break up the file into chunks. Hash each chunk so we can verify that it hasn't
   been corrupted when we receive it. Send over each chunk. Also send over the
   chunk index so we know what order the chunk should be in. The sender and receiver
   should cache the progress of the file transfer (current chunk index).
   The receiver should have a .part file that we'll append chunks to. Then when
   it receives all the chunks it'll rename the file and set permissions and stuff.

   Pending transfers are an app problem, we can just cache the files we want to
   transfer, then when we connect to peers we start transfering the files.

   To resume transfers, we can set start_chunk_index in the START_TRANSFER message.

   To cancel a transfer we can send a CANCEL_TRANSFER message. The receiver will
   handle that accordingly.
